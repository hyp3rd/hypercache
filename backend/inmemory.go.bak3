package backend

import (
	"fmt"
	"sort"
	"sync"

	datastructure "github.com/hyp3rd/hypercache/datastructure/v2"
	"github.com/hyp3rd/hypercache/errors"
	"github.com/hyp3rd/hypercache/models"
	"github.com/hyp3rd/hypercache/types"
)

// InMemory is a cache backend that stores the items in memory, leveraging a custom `ConcurrentMap`.
type InMemory struct {
	items            datastructure.ConcurrentMap[string, *models.Item] // map to store the items in the cache
	capacity         int                                               // capacity of the cache, limits the number of items that can be stored in the cache
	maxCacheSize     int                                               // maxCacheSize instructs the cache not allocate more memory than this limit, value in MB, 0 means no limit
	memoryAllocation int                                               // memoryAllocation is the current memory allocation of the cache, value in bytes
	mutex            sync.RWMutex                                      // mutex to protect the cache from concurrent access
	SortFilters                                                        // filters applied when listing the items in the cache
}

// NewInMemory creates a new in-memory cache with the given options.
func NewInMemory[T InMemory](opts ...Option[InMemory]) (backend IInMemory[T], err error) {
	InMemory := &InMemory{
		items: datastructure.New[*models.Item](),
	}
	// Apply the backend options
	ApplyOptions(InMemory, opts...)
	// Check if the `capacity` is valid
	if InMemory.capacity < 0 {
		return nil, errors.ErrInvalidCapacity
	}
	// Check if the `maxCacheSize` is valid
	if InMemory.maxCacheSize < 0 {
		return nil, errors.ErrInvalidMaxCacheSize
	}

	return InMemory, nil
}

// SetCapacity sets the capacity of the cache.
func (cacheBackend *InMemory) SetCapacity(capacity int) {
	if capacity < 0 {
		return
	}
	cacheBackend.capacity = capacity
}

// Capacity returns the capacity of the cacheBackend.
func (cacheBackend *InMemory) Capacity() int {
	return cacheBackend.capacity
}

// Count returns the number of items in the cache.
func (cacheBackend *InMemory) Count() int {
	return cacheBackend.items.Count()
}

// Size returns the number of items in the cacheBackend.
func (cacheBackend *InMemory) Size() int {
	return cacheBackend.memoryAllocation
}

// MaxCacheSize returns the maximum size in bytes of the cacheBackend.
func (cacheBackend *InMemory) MaxCacheSize() int {
	return cacheBackend.maxCacheSize
}

// Get retrieves the item with the given key from the cacheBackend. If the item is not found, it returns nil.
func (cacheBackend *InMemory) Get(key string) (item *models.Item, ok bool) {
	item, ok = cacheBackend.items.Get(key)
	if !ok {
		return nil, false
	}
	// return the item
	return item, true
}

// Set adds a Item to the cache.
func (cacheBackend *InMemory) Set(item *models.Item) error {
	// Check for invalid key, value, or duration
	if err := item.Valid(); err != nil {
		models.ItemPool.Put(item)
		return err
	}

	cacheBackend.mutex.Lock()
	defer cacheBackend.mutex.Unlock()
	// Set the size of the item
	err := item.SetSize()
	if err != nil {
		return err
	}

	// check if adding this item will exceed the maxCacheSize
	cacheBackend.memoryAllocation = cacheBackend.memoryAllocation + item.Size
	if cacheBackend.maxCacheSize > 0 && cacheBackend.memoryAllocation > cacheBackend.maxCacheSize {
		return errors.ErrCacheFull
	}

	cacheBackend.items.Set(item.Key, item)
	return nil
}

// List returns a list of all items in the cache filtered and ordered by the given options
func (cacheBackend *InMemory) List(options ...FilterOption[InMemory]) ([]*models.Item, error) {
	// Apply the filter options
	ApplyFilterOptions(cacheBackend, options...)

	items := make([]*models.Item, 0, cacheBackend.items.Count())
	wg := sync.WaitGroup{}
	wg.Add(cacheBackend.items.Count())
	for item := range cacheBackend.items.IterBuffered() {
		go func(item datastructure.Tuple[string, *models.Item]) {
			defer wg.Done()
			if cacheBackend.FilterFunc == nil || cacheBackend.FilterFunc(item.Val) {
				items = append(items, item.Val)
			}
		}(item)
	}
	wg.Wait()

	if cacheBackend.SortBy == "" {
		return items, nil
	}

	var sorter sort.Interface
	switch cacheBackend.SortBy {
	case types.SortByKey.String():
		sorter = &itemSorterByKey{items: items}
	case types.SortByLastAccess.String():
		sorter = &itemSorterByLastAccess{items: items}
	case types.SortByAccessCount.String():
		sorter = &itemSorterByAccessCount{items: items}
	case types.SortByExpiration.String():
		sorter = &itemSorterByExpiration{items: items}
	default:
		return nil, fmt.Errorf("unknown sortBy field: %s", cacheBackend.SortBy)
	}

	if !cacheBackend.SortAscending {
		sorter = sort.Reverse(sorter)
	}

	sort.Sort(sorter)
	return items, nil
}

// Remove removes items with the given key from the cacheBackend. If an item is not found, it does nothing.
func (cacheBackend *InMemory) Remove(keys ...string) (err error) {
	//TODO: determine if handling the error or not
	// var ok bool
	// item := models.ItemPool.Get().(*models.Item)
	// defer models.ItemPool.Put(item)
	for _, key := range keys {
		item, ok := cacheBackend.items.Get(key)
		if ok {
			// remove the item from the cacheBackend and update the memory allocation
			cacheBackend.memoryAllocation = cacheBackend.memoryAllocation - item.Size
			cacheBackend.items.Remove(key)
		}
	}
	return
}

// Clear removes all items from the cacheBackend.
func (cacheBackend *InMemory) Clear() {
	// clear the cacheBackend
	cacheBackend.items.Clear()
	// reset the memory allocation
	cacheBackend.memoryAllocation = 0
}
